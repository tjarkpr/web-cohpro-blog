# Tracing Log-Messages and Exceptions in Distributed Systems
###### Implementing the W3C Trace Context Standard in .NET Applications
Modern applications tend to shift away from a monolithic towards a distributed infrastructure by design. Instead of a classic separation of frontend, backend and data management today’s application development focus on a separation of core functionality and providing such as an atomic service. Applications designed by this principal allow services to be exchanged, extended or even scaled in case of an application rollout. The potential of scaling by design plays a key role in application provisioning through a cloud provider. Services that are used by different applications are often also referred to as microservices. Microservices exists in the case of a classic separation in the frontend as well as in the backend and allow a distributed provisioning of applications parts.

Often the provisioning and hosting of an application through a cloud provider leads to network and geolocation specific differences of the included microservices. Such differences can often be minimized by configuring the hosting of container instances or cloud functions to a specific region or datacenter. Though communication channels need to be implemented to allow the predefined exchange between the microservices. This is achieved by opening virtual networks between container instances such that microservice clusters emerge.

Such a distributed infrastructure provides key benefits for the lifecycle of modern applications. Though one of the challenges in the development of these applications is the tracing of logging entries and exceptions. In the lifecycle of an application the tracing of abnormalities and bugs is key for improving customer service and satisfaction and minimizing security risks. In case of a monolithic approach a single system would host an instance of the application and therefore encapsulates the tracing of all log messages and exceptions (e.g., database exceptions can directly be traced backwards to a single request). Since the use of microservices which are mostly hosted in different environments on different systems the tracing could even be handled by different tracing vendors. This requires an overarching tracing context that connects different traces with each other.

The W3C Trace Context is a standard that tries to define an industry solution for connecting traces across different systems even with different tracing vendors. It defines a header concept for the communication between microservices (incl. frontend services). The header concept suggests two different header elements. For the overarching identification of connected traces, the concept suggests a so called Traceparent-Header element. It consists of a version number, trace id, parent id and trace flags:

- The version number is an agreement characteristic between the tracing vendors.
- The trace id, often referred to as operation id, generally identifies a call stack through the microservices. Since the standard doesn’t define the scope of the trace / operation it is also reasonable to use it for a complete workflow that consists of different calls.
- The parent id can be used for supporting nested traces over different systems. By supplying the span id of the local trace as the parent id with the trace context the global trace can be nested and take different paths.
- The trace flags define how the trace id has been generated and how a tracing vendor should handle a new trace id. The trace id should be generated globally unique and at least partially pseudo-random. Also, the trace id can be sampled by a tracing vendor to minimize the mass of recurring traces on a production system.

The header concept also consists of a so called Tracestate-Header. This header element is optional and used for multi- vendor identification.

For implementing the W3C Trace Context in .NET applications this article focusses on using Microsoft Azure Application Insights4 as a centralized storage and analytics tool for log messages and exceptions. Furthermore, it is tightly integrated into the .NET landscape via NuGet packages. The application insights package already implements the automatic recognition of W3C Trace Context header elements and assigns them to the related log messages and exceptions. They can also be found in the current activity which is generally scoped to an incoming request. Although it does not automatically recognize the header for other communication channels like an event bus or a real-time communication provider. Another disadvantage is the lack of automatic response header assigning. This can be achieved by implementing a middleware which propagates the latest span id as the parent id for the Traceparent- Header. This would also allow to react on different trace flags, version numbers or tracing vendors.

The W3C Trace Context standard can therefore be an attractive and fast way to implement a solution for tracing log messages and exceptions in a distributed system.